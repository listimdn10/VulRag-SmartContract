{
    "id": "SWC-113",
    "description": [
        "External calls can fail accidentally or deliberately, which can cause a DoS condition in the contract. To minimize the damage caused by such failures, it is better to isolate each external call into its own transaction that can be initiated by the recipient of the call. This is especially relevant for payments, where it is better to let users withdraw funds rather than push funds to them automatically (this also reduces the chance of problems with the gas limit)."
    ],
    "send_loop.sol": "/*\n * @source: https://consensys.github.io/smart-contract-best-practices/known_attacks/#dos-with-unexpected-revert\n * @author: ConsenSys Diligence\n * Modified by Bernhard Mueller\n */\n\npragma solidity 0.4.24;\n\ncontract Refunder {\n\naddress[] private refundAddresses;\nmapping (address => uint) public refunds;\n\n constructor() {\n refundAddresses.push(0x79B483371E87d664cd39491b5F06250165e4b184);\n refundAddresses.push(0x79B483371E87d664cd39491b5F06250165e4b185);\n }\n\n \n function refundAll() public {\n for(uint x; x < refundAddresses.length; x++) { \n require(refundAddresses[x].send(refunds[refundAddresses[x]])); \n }\n }\n\n}\n",
    "send_loop_fixed.sol": "pragma solidity 0.4.24;\n\ncontract VulnerableRefunder {\n    address[] private recipients; // Changed to private to control access\n    mapping(address => uint) public balances;\n\n    constructor() public {\n        // Add some example recipients\n        recipients.push(0x1111111111111111111111111111111111111111);\n        recipients.push(0x2222222222222222222222222222222222222222);\n        recipients.push(0x3333333333333333333333333333333333333333);\n    }\n\n    // Allow deposits to fund the contract\n    function deposit() public payable {\n        require(msg.value > 0, \"Must send ETH to deposit\");\n    }\n\n    // Vulnerable function: pushes payments in a loop (SWC-113)\n    function distributePayments() public {\n        // Store initial balances\n        for (uint i = 0; i < recipients.length; i++) {\n            balances[recipients[i]] = 1 ether;\n        }\n\n        // Distribute payments - still vulnerable to SWC-113\n        for (uint j = 0; j < recipients.length; j++) {\n            require(\n                recipients[j].send(balances[recipients[j]]),\n                \"Payment failed\"\n            );\n            balances[recipients[j]] = 0;\n        }\n    }\n\n    // Function to add new recipient\n    function addRecipient(address newRecipient) public {\n        recipients.push(newRecipient);\n    }\n\n    // Safe getter for recipients with bounds checking\n    function getRecipient(uint index) public view returns (address) {\n        require(index < recipients.length, \"Index out of bounds\");\n        return recipients[index];\n    }\n\n    // Getter for recipients length\n    function getRecipientsCount() public view returns (uint) {\n        return recipients.length;\n    }\n}"
}