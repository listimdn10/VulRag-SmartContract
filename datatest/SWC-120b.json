{
    "id": "SWC-120",
    "description": [
        "Ability to generate random numbers is very helpful in all kinds of applications. One obvious example is gambling DApps, where pseudo-random number generator is used to pick the winner. However, creating a strong enough source of randomness in Ethereum is very challenging. For example, use ofblock.timestampis insecure, as a miner can choose to provide any timestamp within a few seconds and still get his block accepted by others. Use ofblockhash,block.difficultyand other fields is also insecure, as they're controlled by the miner. If the stakes are high, the miner can mine lots of blocks in a short time by renting hardware, pick the block that has required block hash for him to win, and drop all others."
    ],
    "old_blockhash.sol": "pragma solidity ^0.4.24;\n\n\n\ncontract PredictTheBlockHashChallenge {\n\n struct guess{\n uint block;\n bytes32 guess;\n }\n\n mapping(address => guess) guesses;\n\n constructor() public payable {\n require(msg.value == 1 ether);\n }\n\n function lockInGuess(bytes32 hash) public payable {\n require(guesses[msg.sender].block == 0);\n require(msg.value == 1 ether);\n\n guesses[msg.sender].guess = hash;\n guesses[msg.sender].block = block.number + 1;\n }\n\n function settle() public {\n require(block.number > guesses[msg.sender].block);\n\n bytes32 answer = blockhash(guesses[msg.sender].block);\n\n guesses[msg.sender].block = 0;\n if (guesses[msg.sender].guess == answer) {\n msg.sender.transfer(2 ether);\n }\n }\n}\n",
    "old_blockhash_fixed.sol": "pragma solidity ^0.4.24;\n\n\n\ncontract PredictTheBlockHashChallenge {\n\n struct guess{\n uint block;\n bytes32 guess;\n }\n\n mapping(address => guess) guesses;\n\n constructor() public payable {\n require(msg.value == 1 ether);\n }\n\n function lockInGuess(bytes32 hash) public payable {\n require(guesses[msg.sender].block == 0);\n require(msg.value == 1 ether);\n\n guesses[msg.sender].guess = hash;\n guesses[msg.sender].block = block.number + 1;\n }\n\n function settle() public {\n require(block.number > guesses[msg.sender].block +10);\n \n \n if(guesses[msg.sender].block - block.number < 256){\n bytes32 answer = blockhash(guesses[msg.sender].block);\n\n guesses[msg.sender].block = 0;\n if (guesses[msg.sender].guess == answer) {\n msg.sender.transfer(2 ether);\n }\n }\n else{\n revert(\"Sorry your lottery ticket has expired\");\n }\n }\n}\n"
}