{
    "id": "SWC-105",
    "description": [
        "Due to missing or insufficient access controls, malicious parties can withdraw some or all Ether from the contract account.",
        "This bug is sometimes caused by unintentionally exposing initialization functions. By wrongly naming a function intended to be a constructor, the constructor code ends up in the runtime byte code and can be called by anyone to re-initialize the contract."
    ],
    "multiowned_vulnerable.sol": "pragma solidity ^0.4.23;\n\n/**\n * @title MultiOwnable\n */\ncontract MultiOwnable {\n address public root;\n mapping (address => address) public owners; \n\n /**\n  * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n  * account.\n  */\n constructor() public {\n root = msg.sender;\n owners[root] = root;\n }\n\n /**\n  * @dev Throws if called by any account other than the owner.\n  */\n modifier onlyOwner() {\n require(owners[msg.sender] != 0);\n _;\n }\n\n /**\n  * @dev Adding new owners\n  * Note that the \"onlyOwner\" modifier is missing here.\n  */\n function newOwner(address _owner) external returns (bool) {\n require(_owner != 0);\n owners[_owner] = msg.sender;\n return true;\n }\n\n /**\n    * @dev Deleting owners\n    */\n function deleteOwner(address _owner) onlyOwner external returns (bool) {\n require(owners[_owner] == msg.sender || (owners[_owner] != 0 && msg.sender == root));\n owners[_owner] = 0;\n return true;\n }\n}\n\ncontract TestContract is MultiOwnable {\n\n function withdrawAll() onlyOwner {\n msg.sender.transfer(this.balance);\n }\n\n function() payable {\n }\n\n}\n",
    "multiowned_vulnerable_fixed.sol": "pragma solidity ^0.4.23;\n\n/**\n * @title MultiOwnable\n */\ncontract MultiOwnable {\n address public root;\n mapping (address => address) public owners; \n\n /**\n  * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n  * account.\n  */\n constructor() public {\n root = msg.sender;\n owners[root] = root;\n }\n\n /**\n  * @dev Throws if called by any account other than the owner.\n  */\n modifier onlyOwner() {\n require(owners[msg.sender] != 0);\n _;\n }\n\n /**\n  * @dev Adding new owners\n  * Fixed by adding the \"onlyOwner\" modifier.\n  */\n function newOwner(address _owner) onlyOwner external returns (bool) {\n require(_owner != address(0));\n owners[_owner] = msg.sender;\n return true;\n }\n\n /**\n  * @dev Deleting owners\n  */\n function deleteOwner(address _owner) onlyOwner external returns (bool) {\n require(owners[_owner] == msg.sender || (owners[_owner] != 0 && msg.sender == root));\n owners[_owner] = address(0);\n return true;\n }\n}\n\ncontract TestContract is MultiOwnable {\n\n function withdrawAll() onlyOwner public {\n msg.sender.transfer(address(this).balance);\n }\n\n function() public payable {}\n}\n"
}