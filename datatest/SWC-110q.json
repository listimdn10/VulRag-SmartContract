{
    "id": "SWC-110",
    "description": [
        "The Solidity assert() function is meant to assert invariants. Properly functioning code should never reach a failing assert statement. A reachable assertion can mean one of two things:"
    ],
    "simpledschief.sol": "/*\n * @source: https://forum.zeppelin.solutions/t/using-automatic-analysis-tools-with-makerdao-contracts/1021/3\n * Author: Vera Bogdanich Espina / Zeppelin Solutions\n *\n * A simplified version of the MakerDAO DSChief contract.\n*  Tools should output the correct transaction trace (see source link).\n*/\n\ncontract SimpleDSChief {\n mapping(bytes32=>address) public slates;\n mapping(address=>bytes32) public votes;\n mapping(address=>uint256) public approvals;\n mapping(address=>uint256) public deposits;\n\n function lock(uint wad) public {\n deposits[msg.sender] = add(deposits[msg.sender], wad);\n addWeight(wad, votes[msg.sender]);\n }\n\n function free(uint wad) public {\n deposits[msg.sender] = sub(deposits[msg.sender], wad);\n subWeight(wad, votes[msg.sender]);\n }\n\n function voteYays(address yay) public returns (bytes32){\n bytes32 slate = etch(yay);\n voteSlate(slate);\n\n return slate;\n }\n\n function etch(address yay) public returns (bytes32 slate) {\n bytes32 hash = keccak256(abi.encodePacked(yay));\n\n slates[hash] = yay;\n\n return hash;\n }\n\n function voteSlate(bytes32 slate) public {\n uint weight = deposits[msg.sender];\n subWeight(weight, votes[msg.sender]);\n votes[msg.sender] = slate;\n addWeight(weight, votes[msg.sender]);\n }\n\n function addWeight(uint weight, bytes32 slate) internal {\n address yay = slates[slate];\n approvals[yay] = add(approvals[yay], weight);\n }\n\n function subWeight(uint weight, bytes32 slate) internal {\n address yay = slates[slate];\n approvals[yay] = sub(approvals[yay], weight);\n }\n\n function add(uint x, uint y) internal pure returns (uint z) {\n require((z = x + y) >= x);\n }\n\n function sub(uint x, uint y) internal pure returns (uint z) {\n require((z = x - y) <= x);\n }\n\n function checkAnInvariant() public {\n bytes32 senderSlate = votes[msg.sender];\n address option = slates[senderSlate];\n uint256 senderDeposit = deposits[msg.sender];\n\n assert(approvals[option] >= senderDeposit);\n }\n}\n",
    "simpledschief_fixed.sol": "/*\n * @source: https://forum.zeppelin.solutions/t/using-automatic-analysis-tools-with-makerdao-contracts/1021/3\n * Author: Vera Bogdanich Espina / Zeppelin Solutions\n *\n * A simplified version of the MakerDAO DSChief contract.\n * Tools should output the correct transaction trace (see source link).\n */\n\n// SPDX-License-Identifier: MIT\npragma solidity ^0.4.22;\n\ncontract SimpleDSChief {\n    mapping(bytes32 => address) public slates;\n    mapping(address => bytes32) public votes;\n    mapping(address => uint256) public approvals;\n    mapping(address => uint256) public deposits;\n\n    function lock(uint wad) public {\n        deposits[msg.sender] = add(deposits[msg.sender], wad);\n        addWeight(wad, votes[msg.sender]);\n    }\n\n    function free(uint wad) public {\n        deposits[msg.sender] = sub(deposits[msg.sender], wad);\n        subWeight(wad, votes[msg.sender]);\n    }\n\n    function voteYays(address yay) public returns (bytes32) {\n        bytes32 slate = etch(yay);\n        voteSlate(slate);\n        return slate;\n    }\n\n    function etch(address yay) public returns (bytes32 slate) {\n        bytes32 hash = keccak256(abi.encodePacked(yay));\n        slates[hash] = yay;\n        return hash;\n    }\n\n    function voteSlate(bytes32 slate) public {\n        uint weight = deposits[msg.sender];\n        subWeight(weight, votes[msg.sender]);\n        votes[msg.sender] = slate;\n        addWeight(weight, votes[msg.sender]);\n    }\n\n    function addWeight(uint weight, bytes32 slate) internal {\n        address yay = slates[slate];\n        approvals[yay] = add(approvals[yay], weight);\n    }\n\n    function subWeight(uint weight, bytes32 slate) internal {\n        address yay = slates[slate];\n        approvals[yay] = sub(approvals[yay], weight);\n    }\n\n    function add(uint x, uint y) internal pure returns (uint z) {\n        require((z = x + y) >= x, \"Addition overflow\");\n    }\n\n    function sub(uint x, uint y) internal pure returns (uint z) {\n        require((z = x - y) <= x, \"Subtraction underflow\");\n    }\n\n    function checkAnInvariant() public {\n        bytes32 senderSlate = votes[msg.sender];\n        address option = slates[senderSlate];\n        uint256 senderDeposit = deposits[msg.sender];\n        require(approvals[option] >= senderDeposit);\n    }\n}"

}