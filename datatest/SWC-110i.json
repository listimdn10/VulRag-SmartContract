{
    "id": "SWC-110",
    "description": [
        "The Solidity assert() function is meant to assert invariants. Properly functioning code shouldneverreach a failing assert statement. A reachable assertion can mean one of two things:"
    ],
    "mapping_perfomance_2.sol": "/*\n * @source: ChainSecurity\n * @author: Anton Permenev\n */\npragma solidity ^0.4.22;\n\ncontract MappingPerformance2sets{\n\n mapping(bytes32=>uint) m0;\n mapping(bytes32=>uint) m1;\n mapping(bytes32=>uint) m2;\n mapping(bytes32=>uint) m3;\n mapping(bytes32=>uint) m4;\n mapping(bytes32=>uint) m5;\n uint b;\n\n constructor(){\n b = 10;\n }\n\n function set(bytes32 a, uint cond){\n if(cond == 0){\n m0[a] = 5;\n }else if(cond == 1){\n m1[a] = 5;\n }else if(cond == 2){\n m2[a] = 5;\n }else if(cond == 3){\n m3[a] = 5;\n }else if(cond == 4){\n m4[a] = 5;\n }\n }\n function check(bytes32 a0, uint cond0,\n bytes32 a1, uint cond1, bytes32 a){\n set(a0, cond0);\n set(a1, cond1);\n assert(m5[a] == 0);\n }\n}\n",
    "mapping_perfomance_2_fixed.sol": "/*\n * @source: ChainSecurity\n * @author: Anton Permenev\n */\npragma solidity ^0.4.22;\n\ncontract MappingPerformance2sets{\n\n mapping(bytes32=>uint) m0;\n mapping(bytes32=>uint) m1;\n mapping(bytes32=>uint) m2;\n mapping(bytes32=>uint) m3;\n mapping(bytes32=>uint) m4;\n mapping(bytes32=>uint) m5;\n uint b;\n\n constructor() public {\n b = 10;\n }\n\n function set(bytes32 a, uint cond) public {\n if(cond == 0){\n m0[a] = 5;\n }else if(cond == 1){\n m1[a] = 5;\n }else if(cond == 2){\n m2[a] = 5;\n }else if(cond == 3){\n m3[a] = 5;\n }else if(cond == 4){\n m4[a] = 5;\n }\n }\n\n function check(bytes32 a0, uint cond0,\n bytes32 a1, uint cond1, bytes32 a) public {\n set(a0, cond0);\n set(a1, cond1);\n require(m5[a] == 0, \"m5[a] is not zero!\"); // Thay assert() báº±ng require()\n }\n}"

}