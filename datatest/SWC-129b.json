{
    "id": "SWC-129",
    "description": [
        "A typographical error can occur for example when the intent of a defined operation is to sum a number to a variable (+=) but it has accidentally been defined in a wrong way (=+), introducing a typo which happens to be a valid operator. Instead of calculating the sum it initializes the variable again.",
        "The unary + operator is deprecated in new solidity compiler versions."
    ],
    "typo_safe_math.sol": "pragma solidity ^0.4.25;\n\n/** Taken from the OpenZeppelin github\n * @title SafeMath\n * @dev Math operations with safety checks that revert on error\n */\nlibrary SafeMath {\n\n /**\n  * @dev Multiplies two numbers, reverts on overflow.\n  */\n function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n \n \n \n if (a == 0) {\n return 0;\n }\n\n uint256 c = a * b;\n require(c / a == b);\n\n return c;\n }\n\n /**\n  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\n  */\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n require(b > 0); \n uint256 c = a / b;\n \n\n return c;\n }\n\n /**\n  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n  */\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n require(b <= a);\n uint256 c = a - b;\n\n return c;\n }\n\n /**\n  * @dev Adds two numbers, reverts on overflow.\n  */\n function add(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a + b;\n require(c >= a);\n\n return c;\n }\n\n /**\n  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\n  * reverts when dividing by zero.\n  */\n function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n require(b != 0);\n return a % b;\n }\n}\n\n\ncontract TypoSafeMath {\n\n using SafeMath for uint256;\n uint256 public numberOne = 1;\n bool public win = false;\n\n function addOne() public {\n numberOne =+ 1;\n }\n\n function addOneCorrect() public {\n numberOne += 1;\n }\n\n function addOneSafeMath() public {\n numberOne = numberOne.add(1);\n }\n\n function iWin() public {\n if(!win && numberOne>3) {\n win = true;\n }\n }\n}\n",
    "typo_safe_math_fixed.sol": "pragma solidity ^0.4.25;\n\nlibrary SafeMath {\n\n function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n if (a == 0) {\n return 0;\n }\n uint256 c = a * b;\n require(c / a == b);\n return c;\n }\n\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n require(b > 0);\n return a / b;\n }\n\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n require(b <= a);\n return a - b;\n }\n\n function add(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a + b;\n require(c >= a);\n return c;\n }\n\n function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n require(b != 0);\n return a % b;\n }\n}\n\ncontract TypoSafeMath {\n\n using SafeMath for uint256;\n uint256 public numberOne = 1;\n bool public win = false;\n\n function addOne() public {\n numberOne += 1;\n }\n\n function addOneCorrect() public {\n numberOne += 1;\n }\n\n function addOneSafeMath() public {\n numberOne = numberOne.add(1);\n }\n\n function iWin() public {\n if(!win && numberOne > 3) {\n win = true;\n }\n }\n}\n"

}