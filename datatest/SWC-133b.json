{
    "id": "SWC-133",
    "description": [
        "Usingabi.encodePacked()with multiple variable length arguments can, in certain situations, lead to a hash collision. Sinceabi.encodePacked()packs all elements in order regardless of whether they're part of an array, you can move elements between arrays and, so long as all elements are in the same order, it will return the same encoding. In a signature verification situation, an attacker could exploit this by modifying the position of elements in a previous function call to effectively bypass authorization."
    ],
    "access_control.sol": "/*\n * @author: Steve Marx\n */\n\npragma solidity ^0.5.0;\n\nimport \"./ECDSA.sol\";\n\ncontract AccessControl {\n using ECDSA for bytes32;\n mapping(address => bool) isAdmin;\n mapping(address => bool) isRegularUser;\n \n function addUsers(\n address[] calldata admins,\n address[] calldata regularUsers,\n bytes calldata signature\n )\n external\n {\n if (!isAdmin[msg.sender]) {\n \n bytes32 hash = keccak256(abi.encodePacked(admins, regularUsers));\n address signer = hash.toEthSignedMessageHash().recover(signature);\n require(isAdmin[signer], \"Only admins can add users.\");\n }\n for (uint256 i = 0; i < admins.length; i++) {\n isAdmin[admins[i]] = true;\n }\n for (uint256 i = 0; i < regularUsers.length; i++) {\n isRegularUser[regularUsers[i]] = true;\n }\n }\n}\n",
    "access_control_fixed_2.sol": "/*\n * @author: Steve Marx\n * Modified by Kaden Zipfel\n */\n\npragma solidity ^0.5.0;\n\nimport \"./ECDSA.sol\";\n\ncontract AccessControl {\n using ECDSA for bytes32;\n mapping(address => bool) isAdmin;\n mapping(address => bool) isRegularUser;\n \n function addUsers(\n \n address[3] calldata admins,\n address[3] calldata regularUsers,\n bytes calldata signature\n )\n external\n {\n if (!isAdmin[msg.sender]) {\n \n bytes32 hash = keccak256(abi.encodePacked(admins, regularUsers));\n address signer = hash.toEthSignedMessageHash().recover(signature);\n require(isAdmin[signer], \"Only admins can add users.\");\n }\n for (uint256 i = 0; i < admins.length; i++) {\n isAdmin[admins[i]] = true;\n }\n for (uint256 i = 0; i < regularUsers.length; i++) {\n isRegularUser[regularUsers[i]] = true;\n }\n }\n}\n"
}