{
    "id": "SWC-120",
    "description": [
        "Ability to generate random numbers is very helpful in all kinds of applications. One obvious example is gambling DApps, where pseudo-random number generator is used to pick the winner. However, creating a strong enough source of randomness in Ethereum is very challenging. For example, use ofblock.timestampis insecure, as a miner can choose to provide any timestamp within a few seconds and still get his block accepted by others. Use ofblockhash,block.difficultyand other fields is also insecure, as they're controlled by the miner. If the stakes are high, the miner can mine lots of blocks in a short time by renting hardware, pick the block that has required block hash for him to win, and drop all others."
    ],
    "guess_the_random_number.sol": "/*\n * @source: https://capturetheether.com/challenges/lotteries/guess-the-random-number/\n * @author: Steve Marx\n */\n\npragma solidity ^0.4.21;\n\ncontract GuessTheRandomNumberChallenge {\n uint8 answer;\n\n function GuessTheRandomNumberChallenge() public payable {\n require(msg.value == 1 ether);\n answer = uint8(keccak256(block.blockhash(block.number - 1), now));\n }\n\n function isComplete() public view returns (bool) {\n return address(this).balance == 0;\n }\n\n function guess(uint8 n) public payable {\n require(msg.value == 1 ether);\n\n if (n == answer) {\n msg.sender.transfer(2 ether);\n }\n }\n}\n",
    "guess_the_random_number_fixed.sol": "/*\n * @source: https://capturetheether.com/challenges/lotteries/guess-the-random-number/\n * @author: Steve Marx\n */\n\npragma solidity ^0.4.25;\n\ncontract GuessTheRandomNumberChallenge {\n uint8 answer;\n uint8 commitedGuess;\n uint commitBlock;\n address guesser;\n\n function GuessTheRandomNumberChallenge() public payable {\n require(msg.value == 1 ether);\n }\n\n function isComplete() public view returns (bool) {\n return address(this).balance == 0;\n }\n\n \n function guess(uint8 _guess) public payable {\n require(msg.value == 1 ether);\n commitedGuess = _guess;\n commitBlock = block.number;\n guesser = msg.sender;\n }\n function recover() public {\n \n require(block.number > commitBlock + 20 && commitBlock+20 > block.number - 256);\n require(guesser == msg.sender);\n\n if(uint(blockhash(commitBlock+20)) == commitedGuess){\n msg.sender.transfer(2 ether);\n }\n }\n}\n"
}