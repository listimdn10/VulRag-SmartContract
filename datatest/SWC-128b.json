{
    "id": "SWC-128",
    "description": [
        "When smart contracts are deployed or functions inside them are called, the execution of these actions always requires a certain amount of gas, based of how much computation is needed to complete them. The Ethereum network specifies a block gas limit and the sum of all transactions included in a block can not exceed the threshold.",
        "Programming patterns that are harmless in centralized applications can lead to Denial of Service conditions in smart contracts when the cost of executing a function exceeds the block gas limit. Modifying an array of unknown size, that increases in size over time, can lead to such a Denial of Service condition."
    ],
    "dos_number.sol": "pragma solidity ^0.4.25;\n\ncontract DosNumber {\n\n uint numElements = 0;\n uint[] array;\n\n function insertNnumbers(uint value,uint numbers) public {\n\n \n for(uint i=0;i<numbers;i++) {\n if(numElements == array.length) {\n array.length += 1;\n }\n array[numElements++] = value;\n }\n }\n\n function clear() public {\n require(numElements>1500);\n numElements = 0;\n }\n\n \n function clearDOS() public {\n\n \n require(numElements>1500);\n array = new uint[](0);\n numElements = 0;\n }\n\n function getLengthArray() public view returns(uint) {\n return numElements;\n }\n\n function getRealLengthArray() public view returns(uint) {\n return array.length;\n }\n}\n",
    "dos_number_fixed.sol": "pragma solidity ^0.4.25;\n\ncontract DosNumber {\n    uint numElements = 0;\n    uint[] array;\n\n    function insertNnumbers(uint value, uint numbers) public {\n        require(numbers > 0, \"Number of elements must be greater than zero\");\n\n        for (uint i = 0; i < numbers; i++) {\n            array.push(value); // Efficiently pushing to the array\n            numElements++;\n        }\n    }\n\n    function clearBatch(uint batchSize) public {\n        require(numElements > 1500, \"Not enough elements to clear\");\n        require(batchSize > 0, \"Batch size must be greater than zero\");\n\n        uint deleteCount = batchSize > numElements ? numElements : batchSize;\n        for (uint i = 0; i < deleteCount; i++) {\n            array[numElements - 1] = 0;  \n            numElements--; \n        }\n\n        if (numElements == 0) {\n            array.length = 0;  // Reduce storage size only when safe\n        }\n    }\n\n    function getLengthArray() public view returns (uint) {\n        return numElements;\n    }\n\n    function getRealLengthArray() public view returns (uint) {\n        return array.length;\n    }\n}"

}