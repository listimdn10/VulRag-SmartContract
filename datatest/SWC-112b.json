{
    "id": "SWC-112",
    "description": [
        "There exists a special variant of a message call, nameddelegatecallwhich is identical to a message call apart from the fact that the code at the target address is executed in the context of the calling contract andmsg.senderandmsg.valuedo not change their values. This allows a smart contract to dynamically load code from a different address at runtime. Storage, current address and balance still refer to the calling contract.",
        "Calling into untrusted contracts is very dangerous, as the code at the target address can change any storage values of the caller and has full control over the caller's balance."
    ],
    "proxy_pattern_false_positive.sol": "pragma solidity ^0.4.24;\n\ncontract proxy{\n address owner;\n\n function proxyCall(address _to, bytes _data) external {\n require( !_to.delegatecall(_data));\n }\n function withdraw() external{\n require(msg.sender == owner);\n msg.sender.transfer(address(this).balance);\n }\n}\n\n/*\nYou can't use proxyCall to change the owner address as either:\n\n1) the delegatecall reverts and thus does not change owner\n2) the delegatecall does not revert and therefore will cause the proxyCall to revert and preventing owner from changing\n\nThis false positive may seem like a really edge case, however since you can revert data back to proxy this patern is useful for proxy architectures\n*/\n",
    "proxy_pattern_false_positive_fixed.sol": "pragma solidity ^0.4.24;\n\ncontract Proxy {\n    address public owner;\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Caller is not the owner\");\n        _;\n    }\n\n    constructor() public {\n        owner = msg.sender;\n    }\n}"
}