{
    "id": "SWC-101",
    "description": [
        "An overflow/underflow happens when an arithmetic operation reaches the maximum or minimum size of a type. For instance if a number is stored in the uint8 type, it means that the number is stored in a 8 bits unsigned number ranging from 0 to 2^8-1. In computer programming, an integer overflow occurs when an arithmetic operation attempts to create a numeric value that is outside of the range that can be represented with a given number of bits â€“ either larger than the maximum or lower than the minimum representable value."
    ],
    "tokensalechallenge.sol": "/*\n * @source: https://capturetheether.com/challenges/math/token-sale/\n * @author: Steve Marx\n */\n\npragma solidity ^0.4.21;\n\ncontract TokenSaleChallenge {\n mapping(address => uint256) public balanceOf;\n uint256 constant PRICE_PER_TOKEN = 1 ether;\n\n function TokenSaleChallenge(address _player) public payable {\n require(msg.value == 1 ether);\n }\n\n function isComplete() public view returns (bool) {\n return address(this).balance < 1 ether;\n }\n\n function buy(uint256 numTokens) public payable {\n require(msg.value == numTokens * PRICE_PER_TOKEN);\n\n balanceOf[msg.sender] += numTokens;\n }\n\n function sell(uint256 numTokens) public {\n require(balanceOf[msg.sender] >= numTokens);\n\n balanceOf[msg.sender] -= numTokens;\n msg.sender.transfer(numTokens * PRICE_PER_TOKEN);\n }\n}\n",
    "tokensalechallenge_fixed.sol": "/*\n * @source: https://capturetheether.com/challenges/math/token-sale/\n * @author: Steve Marx\n * @fix: Prevent integer overflow in buy() function\n */\n\npragma solidity ^0.4.21;\n\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n if (a == 0) return 0;\n uint256 c = a * b;\n require(c / a == b);\n return c;\n }\n}\n\ncontract TokenSaleChallenge {\n using SafeMath for uint256;\n\n mapping(address => uint256) public balanceOf;\n uint256 constant PRICE_PER_TOKEN = 1 ether;\n\n function TokenSaleChallenge(address _player) public payable {\n require(msg.value == 1 ether);\n }\n\n function isComplete() public view returns (bool) {\n return address(this).balance < 1 ether;\n }\n\n function buy(uint256 numTokens) public payable {\n uint256 requiredValue = numTokens.mul(PRICE_PER_TOKEN);\n require(msg.value == requiredValue);\n\n balanceOf[msg.sender] += numTokens;\n }\n\n function sell(uint256 numTokens) public {\n require(balanceOf[msg.sender] >= numTokens);\n\n balanceOf[msg.sender] -= numTokens;\n msg.sender.transfer(numTokens.mul(PRICE_PER_TOKEN));\n }\n}\n"
}