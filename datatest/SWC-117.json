{
    "id": "SWC-117",
    "description": [
        "The implementation of a cryptographic signature system in Ethereum contracts often assumes that the signature is unique, but signatures can be altered without the possession of the private key and still be valid. The EVM specification defines several so-called ‘precompiled’ contracts one of them beingecrecoverwhich executes the elliptic curve public key recovery. A malicious user can slightly modify the three valuesv,randsto create other valid signatures. A system that performs signature verification on contract level might be susceptible to attacks if the signature is part of the signed message hash. Valid signatures could be created by a malicious user to replay previously signed messages."
    ],
    "transaction_malleablity.sol": "pragma solidity ^0.4.24;\n\ncontract transaction_malleablity{\n mapping(address => uint256) balances;\n mapping(bytes32 => bool) signatureUsed;\n\n constructor(address[] owners, uint[] init){\n require(owners.length == init.length);\n for(uint i=0; i < owners.length; i ++){\n balances[owners[i]] = init[i];\n }\n }\n\n function transfer(\n bytes _signature,\n address _to,\n uint256 _value,\n uint256 _gasPrice,\n uint256 _nonce)\n public\n returns (bool)\n {\n bytes32 txid = keccak256(abi.encodePacked(getTransferHash(_to, _value, _gasPrice, _nonce), _signature));\n require(!signatureUsed[txid]);\n\n address from = recoverTransferPreSigned(_signature, _to, _value, _gasPrice, _nonce);\n\n require(balances[from] > _value);\n balances[from] -= _value;\n balances[_to] += _value;\n\n signatureUsed[txid] = true;\n }\n\n function recoverTransferPreSigned(\n bytes _sig,\n address _to,\n uint256 _value,\n uint256 _gasPrice,\n uint256 _nonce)\n public\n view\n returns (address recovered)\n {\n return ecrecoverFromSig(getSignHash(getTransferHash(_to, _value, _gasPrice, _nonce)), _sig);\n }\n\n function getTransferHash(\n address _to,\n uint256 _value,\n uint256 _gasPrice,\n uint256 _nonce)\n public\n view\n returns (bytes32 txHash) {\n return keccak256(address(this), bytes4(0x1296830d), _to, _value, _gasPrice, _nonce);\n }\n\n function getSignHash(bytes32 _hash)\n public\n pure\n returns (bytes32 signHash)\n {\n return keccak256(\"\\x19Ethereum Signed Message:\\n32\", _hash);\n }\n\n function ecrecoverFromSig(bytes32 hash, bytes sig)\n public\n pure\n returns (address recoveredAddress)\n {\n bytes32 r;\n bytes32 s;\n uint8 v;\n if (sig.length != 65) return address(0);\n assembly {\n r := mload(add(sig, 32))\n s := mload(add(sig, 64))\n v := byte(0, mload(add(sig, 96)))\n }\n if (v < 27) {\n v += 27;\n }\n if (v != 27 && v != 28) return address(0);\n return ecrecover(hash, v, r, s);\n }\n}\n",
    "transaction_malleablity_fixed.sol": "pragma solidity ^0.4.24;\n\ncontract transaction_malleablity{\n mapping(address => uint256) balances;\n mapping(bytes32 => bool) signatureUsed;\n\n constructor(address[] owners, uint[] init){\n require(owners.length == init.length);\n for(uint i=0; i < owners.length; i ++){\n balances[owners[i]] = init[i];\n }\n }\n\n function transfer(\n bytes _signature,\n address _to,\n uint256 _value,\n uint256 _gasPrice,\n uint256 _nonce)\n public\n returns (bool)\n {\n bytes32 txid = getTransferHash(_to, _value, _gasPrice, _nonce);\n require(!signatureUsed[txid]);\n\n address from = recoverTransferPreSigned(_signature, _to, _value, _gasPrice, _nonce);\n\n require(balances[from] > _value);\n balances[from] -= _value;\n balances[_to] += _value;\n\n signatureUsed[txid] = true;\n }\n\n function recoverTransferPreSigned(\n bytes _sig,\n address _to,\n uint256 _value,\n uint256 _gasPrice,\n uint256 _nonce)\n public\n view\n returns (address recovered)\n {\n return ecrecoverFromSig(getSignHash(getTransferHash(_to, _value, _gasPrice, _nonce)), _sig);\n }\n\n function getTransferHash(\n address _to,\n uint256 _value,\n uint256 _gasPrice,\n uint256 _nonce)\n public\n view\n returns (bytes32 txHash) {\n return keccak256(address(this), bytes4(0x1296830d), _to, _value, _gasPrice, _nonce);\n }\n\n function getSignHash(bytes32 _hash)\n public\n pure\n returns (bytes32 signHash)\n {\n return keccak256(\"\\x19Ethereum Signed Message:\\n32\", _hash);\n }\n\n function ecrecoverFromSig(bytes32 hash, bytes sig)\n public\n pure\n returns (address recoveredAddress)\n {\n bytes32 r;\n bytes32 s;\n uint8 v;\n if (sig.length != 65) return address(0);\n assembly {\n r := mload(add(sig, 32))\n s := mload(add(sig, 64))\n v := byte(0, mload(add(sig, 96)))\n }\n if (v < 27) {\n v += 27;\n }\n if (v != 27 && v != 28) return address(0);\n return ecrecover(hash, v, r, s);\n }\n}\n"
}