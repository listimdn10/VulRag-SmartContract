{
    "id": "SWC-105",
    "description": [
        "Due to missing or insufficient access controls, malicious parties can withdraw some or all Ether from the contract account.",
        "This bug is sometimes caused by unintentionally exposing initialization functions. By wrongly naming a function intended to be a constructor, the constructor code ends up in the runtime byte code and can be called by anyone to re-initialize the contract."
    ],
    "rubixi.sol": "pragma solidity ^0.4.22;\n\ncontract Rubixi {\n    uint private balance = 0;\n    uint private collectedFees = 0;\n    uint private feePercent = 10;\n    uint private pyramidMultiplier = 300;\n    uint private payoutOrder = 0;\n\n    address private creator;\n\n    function DynamicPyramid() public {\n        creator = msg.sender;\n    }\n\n    modifier onlyowner {\n        if (msg.sender == creator) _;\n    }\n\n    struct Participant {\n        address etherAddress;\n        uint payout;\n    }\n\n    Participant[] private participants;\n\n    function() public payable {\n        init();\n    }\n\n    function init() private {\n        if (msg.value < 1 ether) {\n            collectedFees += msg.value;\n            return;\n        }\n\n        uint _fee = feePercent;\n        if (msg.value >= 50 ether) _fee /= 2;\n\n        addPayout(_fee);\n    }\n\n    function addPayout(uint _fee) private {\n        participants.push(Participant(msg.sender, (msg.value * pyramidMultiplier) / 100));\n\n        if (participants.length == 10) pyramidMultiplier = 200;\n        else if (participants.length == 25) pyramidMultiplier = 150;\n\n        balance += (msg.value * (100 - _fee)) / 100;\n        collectedFees += (msg.value * _fee) / 100;\n\n        while (balance > participants[payoutOrder].payout) {\n            uint payoutToSend = participants[payoutOrder].payout;\n            participants[payoutOrder].etherAddress.send(payoutToSend);\n\n            balance -= participants[payoutOrder].payout;\n            payoutOrder += 1;\n        }\n    }\n\n    function collectAllFees() public onlyowner {\n        if (collectedFees == 0) revert();\n        creator.send(collectedFees);\n        collectedFees = 0;\n    }\n\n    function collectFeesInEther(uint _amt) public onlyowner {\n        _amt *= 1 ether;\n        if (_amt > collectedFees) collectAllFees();\n\n        if (collectedFees == 0) revert();\n        creator.send(_amt);\n        collectedFees -= _amt;\n    }\n\n    function collectPercentOfFees(uint _pcent) public onlyowner {\n        if (collectedFees == 0 || _pcent > 100) revert();\n\n        uint feesToCollect = collectedFees / 100 * _pcent;\n        creator.send(feesToCollect);\n        collectedFees -= feesToCollect;\n    }\n\n    function changeOwner(address _owner) public onlyowner {\n        creator = _owner;\n    }\n\n    function changeMultiplier(uint _mult) public onlyowner {\n        if (_mult > 300 || _mult < 120) revert();\n        pyramidMultiplier = _mult;\n    }\n\n    function changeFeePercentage(uint _fee) public onlyowner {\n        if (_fee > 10) revert();\n        feePercent = _fee;\n    }\n}\n",
    "rubixi_fixed.sol": "pragma solidity ^0.4.22;\n\ncontract Rubixi {\n    uint private balance = 0;\n    uint private collectedFees = 0;\n    uint private feePercent = 10;\n    uint private pyramidMultiplier = 300;\n    uint private payoutOrder = 0;\n\n    address private creator;\n\n    constructor() public {\n        creator = msg.sender;\n    }\n\n    modifier onlyOwner {\n        require(msg.sender == creator);\n        _;\n    }\n\n    struct Participant {\n        address etherAddress;\n        uint payout;\n    }\n\n    Participant[] private participants;\n\n    function() public payable {\n        init();\n    }\n\n    function init() private {\n        if (msg.value < 1 ether) {\n            collectedFees += msg.value;\n            return;\n        }\n\n        uint _fee = feePercent;\n        if (msg.value >= 50 ether) _fee /= 2;\n\n        addPayout(_fee);\n    }\n\n    function addPayout(uint _fee) private {\n        participants.push(Participant(msg.sender, (msg.value * pyramidMultiplier) / 100));\n\n        if (participants.length == 10) pyramidMultiplier = 200;\n        else if (participants.length == 25) pyramidMultiplier = 150;\n\n        balance += (msg.value * (100 - _fee)) / 100;\n        collectedFees += (msg.value * _fee) / 100;\n\n        while (balance > participants[payoutOrder].payout) {\n            uint payoutToSend = participants[payoutOrder].payout;\n            participants[payoutOrder].etherAddress.transfer(payoutToSend);\n\n            balance -= participants[payoutOrder].payout;\n            payoutOrder += 1;\n        }\n    }\n\n    function collectAllFees() public onlyOwner {\n        require(collectedFees > 0);\n        creator.transfer(collectedFees);\n        collectedFees = 0;\n    }\n\n    function collectFeesInEther(uint _amt) public onlyOwner {\n        _amt *= 1 ether;\n        if (_amt > collectedFees) collectAllFees();\n\n        require(collectedFees > 0);\n        creator.transfer(_amt);\n        collectedFees -= _amt;\n    }\n\n    function collectPercentOfFees(uint _pcent) public onlyOwner {\n        require(collectedFees > 0 && _pcent <= 100);\n\n        uint feesToCollect = (collectedFees * _pcent) / 100;\n        creator.transfer(feesToCollect);\n        collectedFees -= feesToCollect;\n    }\n\n    function changeOwner(address _owner) public onlyOwner {\n        creator = _owner;\n    }\n\n    function changeMultiplier(uint _mult) public onlyOwner {\n        require(_mult <= 300 && _mult >= 120);\n        pyramidMultiplier = _mult;\n    }\n\n    function changeFeePercentage(uint _fee) public onlyOwner {\n        require(_fee <= 10);\n        feePercent = _fee;\n    }\n}\n"
}