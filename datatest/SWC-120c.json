{
    "id": "SWC-120",
    "description": [
        "Ability to generate random numbers is very helpful in all kinds of applications. One obvious example is gambling DApps, where pseudo-random number generator is used to pick the winner. However, creating a strong enough source of randomness in Ethereum is very challenging. For example, use ofblock.timestampis insecure, as a miner can choose to provide any timestamp within a few seconds and still get his block accepted by others. Use ofblockhash,block.difficultyand other fields is also insecure, as they're controlled by the miner. If the stakes are high, the miner can mine lots of blocks in a short time by renting hardware, pick the block that has required block hash for him to win, and drop all others."
    ],
    "random_number_generator.sol": "pragma solidity ^0.4.25;\n\n\ncontract RandomNumberGenerator {\n uint256 private salt = block.timestamp;\n\n function random(uint max) view private returns (uint256 result) {\n \n uint256 x = salt * 100 / max;\n uint256 y = salt * block.number / (salt % 5);\n uint256 seed = block.number / 3 + (salt % 300) + y;\n uint256 h = uint256(blockhash(seed));\n \n return uint256((h / x)) % max + 1;\n }\n}\n",
    "random_number_generator_fixed.sol": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface VRFCoordinatorV2Interface {\n    function requestRandomWords(\n        bytes32 keyHash,\n        uint64 subscriptionId,\n        uint16 requestConfirmations,\n        uint32 callbackGasLimit,\n        uint32 numWords\n    ) external returns (uint256 requestId);\n}\n\nabstract contract VRFConsumerBaseV2 {\n    function fulfillRandomWords(\n        uint256 requestId,\n        uint256[] memory randomWords\n    ) internal virtual;\n\n    address private immutable vrfCoordinator;\n\n    constructor(address _vrfCoordinator) {\n        vrfCoordinator = _vrfCoordinator;\n    }\n}\n\ncontract RandomNumberGenerator is VRFConsumerBaseV2 {\n    VRFCoordinatorV2Interface COORDINATOR;\n\n    uint64 subscriptionId;\n    address vrfCoordinator = 0x8103B0A8A00be2DDC778e6e7eaa21791Cd364625;\n    bytes32 keyHash =\n        0x6c3699283bda56ad74f6b855546325b68d482e983852a3a5bde69e3ea85e90b3;\n    // Replace with actual keyHash for Chainlink VRF\n    uint16 requestConfirmations = 3;\n    uint32 callbackGasLimit = 100000;\n    uint32 numWords = 1;\n\n    uint256 public randomResult;\n\n    constructor(uint64 _subscriptionId) VRFConsumerBaseV2(vrfCoordinator) {\n        COORDINATOR = VRFCoordinatorV2Interface(vrfCoordinator);\n        subscriptionId = _subscriptionId;\n    }\n\n    function requestRandomNumber() external {\n        COORDINATOR.requestRandomWords(\n            keyHash,\n            subscriptionId,\n            requestConfirmations,\n            callbackGasLimit,\n            numWords\n        );\n    }\n\n    function fulfillRandomWords(\n        uint256 requestId,\n        uint256[] memory randomWords\n    ) internal override {\n        randomResult = randomWords[0];\n    }\n\n    function getRandomNumber(uint max) external view returns (uint256) {\n        require(randomResult > 0, \"Random number not generated yet\");\n        return (randomResult % max) + 1;\n    }\n}\n"
}