{
    "id": "SWC-136",
    "description": [
        "It is a common misconception thatprivatetype variables cannot be read. Even if your contract is not published, attackers can look at contract transactions to determine values stored in the state of the contract. For this reason, it's important that unencrypted private data is not stored in the contract code or state."
    ],
    "odd_even.sol": "/*\n * @source: https://gist.github.com/manojpramesh/336882804402bee8d6b99bea453caadd#file-odd-even-sol\n * @author: https://github.com/manojpramesh\n * Modified by Kaden Zipfel\n */\n\npragma solidity ^0.5.0;\n\ncontract OddEven {\n struct Player {\n address addr;\n uint number;\n }\n\n Player[2] private players;\n uint count = 0;\n\n function play(uint number) public payable {\n require(msg.value == 1 ether, 'msg.value must be 1 eth');\n players[count] = Player(msg.sender, number);\n count++;\n if (count == 2) selectWinner();\n }\n\n function selectWinner() private {\n uint n = players[0].number + players[1].number;\n (bool success, ) = players[n%2].addr.call.value(address(this).balance)(\"\");\n require(success, 'transfer failed');\n delete players;\n count = 0;\n }\n}\n",
    "odd_even_fixed.sol": "/*\n * @source: https://github.com/yahgwai/rps\n * @author: Chris Buckland\n * Modified by Kaden Zipfel\n * Modified by Kacper Å»uk\n */\n\npragma solidity ^0.5.0;\n\ncontract OddEven {\n enum Stage {\n FirstCommit,\n SecondCommit,\n FirstReveal,\n SecondReveal,\n Distribution\n }\n\n struct Player {\n address addr;\n bytes32 commitment;\n bool revealed;\n uint number;\n }\n\n Player[2] private players;\n Stage public stage = Stage.FirstCommit;\n\n function play(bytes32 commitment) public payable {\n \n uint playerIndex;\n if(stage == Stage.FirstCommit) playerIndex = 0;\n else if(stage == Stage.SecondCommit) playerIndex = 1;\n else revert(\"only two players allowed\");\n\n \n \n require(msg.value == 2 ether, 'msg.value must be 2 eth');\n\n \n players[playerIndex] = Player(msg.sender, commitment, false, 0);\n\n \n if(stage == Stage.FirstCommit) stage = Stage.SecondCommit;\n else stage = Stage.FirstReveal;\n }\n\n function reveal(uint number, bytes32 blindingFactor) public {\n \n require(stage == Stage.FirstReveal || stage == Stage.SecondReveal, \"wrong stage\");\n\n \n uint playerIndex;\n if(players[0].addr == msg.sender) playerIndex = 0;\n else if(players[1].addr == msg.sender) playerIndex = 1;\n else revert(\"unknown player\");\n\n \n require(!players[playerIndex].revealed, \"already revealed\");\n\n \n require(keccak256(abi.encodePacked(msg.sender, number, blindingFactor)) == players[playerIndex].commitment, \"invalid hash\");\n\n \n players[playerIndex].number = number;\n\n \n players[playerIndex].revealed = true;\n\n \n if(stage == Stage.FirstReveal) stage = Stage.SecondReveal;\n else stage = Stage.Distribution;\n }\n\n function distribute() public {\n \n require(stage == Stage.Distribution, \"wrong stage\");\n\n \n uint n = players[0].number + players[1].number;\n\n \n players[n%2].addr.call.value(3 ether)(\"\");\n\n \n players[(n+1)%2].addr.call.value(1 ether)(\"\");\n\n \n delete players;\n stage = Stage.FirstCommit;\n }\n}\n"
}