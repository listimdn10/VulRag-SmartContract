{
    "id": "SWC-106",
    "description": [
        "Due to missing or insufficient access controls, malicious parties can self-destruct the contract."
    ],
    "WalletLibrary.sol": "\n\n\n\n\n\n\n\n\n\n\npragma solidity ^0.4.9;\n\ncontract WalletEvents {\n \n\n \n \n event Confirmation(address owner, bytes32 operation);\n event Revoke(address owner, bytes32 operation);\n\n \n event OwnerChanged(address oldOwner, address newOwner);\n event OwnerAdded(address newOwner);\n event OwnerRemoved(address oldOwner);\n\n \n event RequirementChanged(uint newRequirement);\n\n \n event Deposit(address _from, uint value);\n \n event SingleTransact(address owner, uint value, address to, bytes data, address created);\n \n event MultiTransact(address owner, bytes32 operation, uint value, address to, bytes data, address created);\n \n event ConfirmationNeeded(bytes32 operation, address initiator, uint value, address to, bytes data);\n}\n\ncontract WalletAbi {\n \n function revoke(bytes32 _operation) external;\n\n \n function changeOwner(address _from, address _to) external;\n\n function addOwner(address _owner) external;\n\n function removeOwner(address _owner) external;\n\n function changeRequirement(uint _newRequired) external;\n\n function isOwner(address _addr) constant returns (bool);\n\n function hasConfirmed(bytes32 _operation, address _owner) external constant returns (bool);\n\n \n function setDailyLimit(uint _newLimit) external;\n\n function execute(address _to, uint _value, bytes _data) external returns (bytes32 o_hash);\n function confirm(bytes32 _h) returns (bool o_success);\n}\n\ncontract WalletLibrary is WalletEvents {\n \n\n \n struct PendingState {\n uint yetNeeded;\n uint ownersDone;\n uint index;\n }\n\n \n struct Transaction {\n address to;\n uint value;\n bytes data;\n }\n\n \n\n \n modifier onlyowner {\n if (isOwner(msg.sender))\n _;\n }\n \n \n \n modifier onlymanyowners(bytes32 _operation) {\n if (confirmAndCheck(_operation))\n _;\n }\n\n \n\n \n function() payable {\n \n if (msg.value > 0)\n Deposit(msg.sender, msg.value);\n }\n\n \n \n function initMultiowned(address[] _owners, uint _required) only_uninitialized {\n m_numOwners = _owners.length + 1;\n m_owners[1] = uint(msg.sender);\n m_ownerIndex[uint(msg.sender)] = 1;\n for (uint i = 0; i < _owners.length; ++i)\n {\n m_owners[2 + i] = uint(_owners[i]);\n m_ownerIndex[uint(_owners[i])] = 2 + i;\n }\n m_required = _required;\n }\n\n \n function revoke(bytes32 _operation) external {\n uint ownerIndex = m_ownerIndex[uint(msg.sender)];\n \n if (ownerIndex == 0) return;\n uint ownerIndexBit = 2**ownerIndex;\n var pending = m_pending[_operation];\n if (pending.ownersDone & ownerIndexBit > 0) {\n pending.yetNeeded++;\n pending.ownersDone -= ownerIndexBit;\n Revoke(msg.sender, _operation);\n }\n }\n\n \n function changeOwner(address _from, address _to) onlymanyowners(sha3(msg.data)) external {\n if (isOwner(_to)) return;\n uint ownerIndex = m_ownerIndex[uint(_from)];\n if (ownerIndex == 0) return;\n\n clearPending();\n m_owners[ownerIndex] = uint(_to);\n m_ownerIndex[uint(_from)] = 0;\n m_ownerIndex[uint(_to)] = ownerIndex;\n OwnerChanged(_from, _to);\n }\n\n function addOwner(address _owner) onlymanyowners(sha3(msg.data)) external {\n if (isOwner(_owner)) return;\n\n clearPending();\n if (m_numOwners >= c_maxOwners)\n reorganizeOwners();\n if (m_numOwners >= c_maxOwners)\n return;\n m_numOwners++;\n m_owners[m_numOwners] = uint(_owner);\n m_ownerIndex[uint(_owner)] = m_numOwners;\n OwnerAdded(_owner);\n }\n\n function removeOwner(address _owner) onlymanyowners(sha3(msg.data)) external {\n uint ownerIndex = m_ownerIndex[uint(_owner)];\n if (ownerIndex == 0) return;\n if (m_required > m_numOwners - 1) return;\n\n m_owners[ownerIndex] = 0;\n m_ownerIndex[uint(_owner)] = 0;\n clearPending();\n reorganizeOwners(); \n OwnerRemoved(_owner);\n }\n\n function changeRequirement(uint _newRequired) onlymanyowners(sha3(msg.data)) external {\n if (_newRequired > m_numOwners) return;\n m_required = _newRequired;\n clearPending();\n RequirementChanged(_newRequired);\n }\n\n \n function getOwner(uint ownerIndex) external constant returns (address) {\n return address(m_owners[ownerIndex + 1]);\n }\n\n function isOwner(address _addr) constant returns (bool) {\n return m_ownerIndex[uint(_addr)] > 0;\n }\n\n function hasConfirmed(bytes32 _operation, address _owner) external constant returns (bool) {\n var pending = m_pending[_operation];\n uint ownerIndex = m_ownerIndex[uint(_owner)];\n\n \n if (ownerIndex == 0) return false;\n\n \n uint ownerIndexBit = 2**ownerIndex;\n return !(pending.ownersDone & ownerIndexBit == 0);\n }\n\n \n function initDaylimit(uint _limit) only_uninitialized {\n m_dailyLimit = _limit;\n m_lastDay = today();\n }\n \n function setDailyLimit(uint _newLimit) onlymanyowners(sha3(msg.data)) external {\n m_dailyLimit = _newLimit;\n }\n \n function resetSpentToday() onlymanyowners(sha3(msg.data)) external {\n m_spentToday = 0;\n }\n\n \n modifier only_uninitialized { if (m_numOwners > 0) throw; _; }\n\n \n \n function initWallet(address[] _owners, uint _required, uint _daylimit) only_uninitialized {\n initDaylimit(_daylimit);\n initMultiowned(_owners, _required);\n }\n\n \n function kill(address _to) onlymanyowners(sha3(msg.data)) external {\n suicide(_to);\n }\n\n \n \n \n \n function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 o_hash) {\n \n if ((_data.length == 0 && underLimit(_value)) || m_required == 1) {\n \n address created;\n if (_to == 0) {\n created = create(_value, _data);\n } else {\n if (!_to.call.value(_value)(_data))\n throw;\n }\n SingleTransact(msg.sender, _value, _to, _data, created);\n } else {\n \n o_hash = sha3(msg.data, block.number);\n \n if (m_txs[o_hash].to == 0 && m_txs[o_hash].value == 0 && m_txs[o_hash].data.length == 0) {\n m_txs[o_hash].to = _to;\n m_txs[o_hash].value = _value;\n m_txs[o_hash].data = _data;\n }\n if (!confirm(o_hash)) {\n ConfirmationNeeded(o_hash, msg.sender, _value, _to, _data);\n }\n }\n }\n\n function create(uint _value, bytes _code) internal returns (address o_addr) {\n /*\n    assembly {\n      o_addr := create(_value, add(_code, 0x20), mload(_code))\n      jumpi(invalidJumpLabel, iszero(extcodesize(o_addr)))\n    }\n    */\n }\n\n \n \n function confirm(bytes32 _h) onlymanyowners(_h) returns (bool o_success) {\n if (m_txs[_h].to != 0 || m_txs[_h].value != 0 || m_txs[_h].data.length != 0) {\n address created;\n if (m_txs[_h].to == 0) {\n created = create(m_txs[_h].value, m_txs[_h].data);\n } else {\n if (!m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data))\n throw;\n }\n\n MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data, created);\n delete m_txs[_h];\n return true;\n }\n }\n\n \n\n function confirmAndCheck(bytes32 _operation) internal returns (bool) {\n \n uint ownerIndex = m_ownerIndex[uint(msg.sender)];\n \n if (ownerIndex == 0) return;\n\n var pending = m_pending[_operation];\n \n if (pending.yetNeeded == 0) {\n \n pending.yetNeeded = m_required;\n \n pending.ownersDone = 0;\n pending.index = m_pendingIndex.length++;\n m_pendingIndex[pending.index] = _operation;\n }\n \n uint ownerIndexBit = 2**ownerIndex;\n \n if (pending.ownersDone & ownerIndexBit == 0) {\n Confirmation(msg.sender, _operation);\n \n if (pending.yetNeeded <= 1) {\n \n delete m_pendingIndex[m_pending[_operation].index];\n delete m_pending[_operation];\n return true;\n }\n else\n {\n \n pending.yetNeeded--;\n pending.ownersDone |= ownerIndexBit;\n }\n }\n }\n\n function reorganizeOwners() private {\n uint free = 1;\n while (free < m_numOwners)\n {\n while (free < m_numOwners && m_owners[free] != 0) free++;\n while (m_numOwners > 1 && m_owners[m_numOwners] == 0) m_numOwners--;\n if (free < m_numOwners && m_owners[m_numOwners] != 0 && m_owners[free] == 0)\n {\n m_owners[free] = m_owners[m_numOwners];\n m_ownerIndex[m_owners[free]] = free;\n m_owners[m_numOwners] = 0;\n }\n }\n }\n\n \n \n function underLimit(uint _value) internal onlyowner returns (bool) {\n \n if (today() > m_lastDay) {\n m_spentToday = 0;\n m_lastDay = today();\n }\n \n \n if (m_spentToday + _value >= m_spentToday && m_spentToday + _value <= m_dailyLimit) {\n m_spentToday += _value;\n return true;\n }\n return false;\n }\n\n \n function today() private constant returns (uint) { return now / 1 days; }\n\n function clearPending() internal {\n uint length = m_pendingIndex.length;\n\n for (uint i = 0; i < length; ++i) {\n delete m_txs[m_pendingIndex[i]];\n\n if (m_pendingIndex[i] != 0)\n delete m_pending[m_pendingIndex[i]];\n }\n\n delete m_pendingIndex;\n }\n\n \n address constant _walletLibrary = 0xcafecafecafecafecafecafecafecafecafecafe;\n\n \n uint public m_required;\n \n uint public m_numOwners;\n\n uint public m_dailyLimit;\n uint public m_spentToday;\n uint public m_lastDay;\n\n \n uint[256] m_owners;\n\n uint constant c_maxOwners = 250;\n \n mapping(uint => uint) m_ownerIndex;\n \n mapping(bytes32 => PendingState) m_pending;\n bytes32[] m_pendingIndex;\n\n \n mapping (bytes32 => Transaction) m_txs;\n}\n",
    "simple_suicide.sol": "pragma solidity ^0.4.22;\n\ncontract SimpleSuicide {\n\n function sudicideAnyone() {\n selfdestruct(msg.sender);\n }\n\n}\n"
}