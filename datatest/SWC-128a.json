{
    "id": "SWC-128",
    "description": [
        "When smart contracts are deployed or functions inside them are called, the execution of these actions always requires a certain amount of gas, based of how much computation is needed to complete them. The Ethereum network specifies a block gas limit and the sum of all transactions included in a block can not exceed the threshold.",
        "Programming patterns that are harmless in centralized applications can lead to Denial of Service conditions in smart contracts when the cost of executing a function exceeds the block gas limit. Modifying an array of unknown size, that increases in size over time, can lead to such a Denial of Service condition."
    ],
    "dos_address.sol": "pragma solidity ^0.4.25;\n\ncontract DosGas {\n\n address[] creditorAddresses;\n bool win = false;\n\n function emptyCreditors() public {\n if(creditorAddresses.length>1500) {\n creditorAddresses = new address[](0);\n win = true;\n }\n }\n\n function addCreditors() public returns (bool) {\n for(uint i=0;i<350;i++) {\n creditorAddresses.push(msg.sender);\n }\n return true;\n }\n\n function iWin() public view returns (bool) {\n return win;\n }\n\n function numberCreditors() public view returns (uint) {\n return creditorAddresses.length;\n }\n}\n",
    "dos_address_fixed.sol": "pragma solidity ^0.4.25;\n\ncontract DosGas {\n    address[] creditorAddresses;\n    bool win = false;\n\n    function emptyCreditors(uint batchSize) public {\n        require(batchSize > 0, \"Batch size must be greater than zero\");\n\n        uint length = creditorAddresses.length;\n        if (length > 1500) {\n            uint deleteCount = batchSize > length ? length : batchSize;\n            for (uint i = 0; i < deleteCount; i++) {\n                creditorAddresses[length - 1] = address(0);  \n                length--; \n            }\n\n            creditorAddresses.length = length;\n\n            if (creditorAddresses.length == 0) {\n                win = true;\n            }\n        }\n    }\n\n    function addCreditors(uint batchSize) public returns (bool) {\n        require(batchSize > 0, \"Batch size must be greater than zero\");\n\n        for (uint i = 0; i < batchSize; i++) {\n            creditorAddresses.push(msg.sender);\n        }\n        return true;\n    }\n\n    function iWin() public view returns (bool) {\n        return win;\n    }\n\n    function numberCreditors() public view returns (uint) {\n        return creditorAddresses.length;\n    }\n}\n"

}