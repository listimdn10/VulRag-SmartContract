{
    "id": "SWC-114",
    "description": [
        "The Ethereum network processes transactions in blocks, with new blocks getting confirmed approximately every 17 seconds. Miners review the transactions they have received and select which ones to include in a block, based on who has paid a high enough gas price to be included. Additionally, when transactions are sent to the Ethereum network, they are forwarded to each node for processing. Thus, a person who is running an Ethereum node can tell which transactions are going to occur before they are finalized. A race condition vulnerability occurs when code depends on the order of the transactions submitted to it.",
        "The simplest example of a race condition is when a smart contract gives a reward for submitting information. Suppose a contract will give out 1 token to the first person who solves a math problem. Alice solves the problem and submits the answer to the network with a standard gas price. Eve runs an Ethereum node and can see the answer to the math problem in the transaction that Alice submitted to the network. So, Eve submits the answer to the network with a much higher gas price, and thus it gets processed and committed before Alice's transaction. Eve receives one token, and Alice gets nothing, even though it was Alice who worked to solve the problem. A common way this occurs in practice is when a contract rewards people for calling out bad behavior in a protocol by giving a bad actor's deposit to the person who proved they were misbehaving.",
        "The race condition that happens most frequently on the network today is the race condition in the ERC20 token standard. The ERC20 token standard includes a function called 'approve', which allows an address to approve another address to spend tokens on their behalf. Assume that Alice has approved Eve to spend n of her tokens, then Alice decides to change Eve's approval to m tokens. Alice submits a function call to approve with the value n for Eve. Eve runs an Ethereum node, so she knows that Alice is going to change her approval to m. Eve then submits a transferFrom request, sending n of Alice's tokens to herself, but gives it a much higher gas price than Alice's transaction. The transferFrom executes first so gives Eve n tokens and sets Eve's approval to zero. Then Alice's transaction executes and sets Eve's approval to m. Eve then sends those m tokens to herself as well. Thus, Eve gets n + m tokens, even though she should have gotten at most max(n,m)."
    ],
    "eth_tx_order_dependence_minimal.sol": "/*\n * @source: https://github.com/ConsenSys/evm-analyzer-benchmark-suite\n * @author: Suhabe Bugrara\n */\n\npragma solidity ^0.4.16;\n\ncontract EthTxOrderDependenceMinimal {\n address public owner;\n bool public claimed;\n uint public reward;\n\n function EthTxOrderDependenceMinimal() public {\n owner = msg.sender;\n }\n\n function setReward() public payable {\n require (!claimed);\n\n require(msg.sender == owner);\n owner.transfer(reward);\n reward = msg.value;\n }\n\n function claimReward(uint256 submission) {\n require (!claimed);\n require(submission < 10);\n\n msg.sender.transfer(reward);\n claimed = true;\n }\n}\n",
    "eth_tx_order_dependence_minimal_fixed.sol": "pragma solidity ^0.4.24;\n\ncontract EthTxOrderDependenceMinimal {\n    address public owner;\n    bool public claimed;\n    uint public reward;\n\n    mapping(address => uint) public pendingRewards;\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Caller is not the owner\");\n        _;\n    }\n\n    // Đổi tên hàm khởi tạo thành tên hợp đồng (dành cho Solidity ^0.4.x)\n    function EthTxOrderDependenceMinimal() public {\n        owner = msg.sender;\n    }\n\n    function setReward() public payable onlyOwner {\n        require(!claimed, \"Reward already claimed\");\n\n        // Refund the previous reward to the owner before updating\n        if (reward > 0) {\n            pendingRewards[owner] += reward;\n        }\n\n        reward = msg.value;\n    }\n\n    function claimReward(uint256 submission) public {\n        require(!claimed, \"Reward already claimed\");\n        require(submission < 10, \"Invalid submission\");\n\n        claimed = true;\n        pendingRewards[msg.sender] += reward;\n    }\n\n    function withdraw() public {\n        uint amount = pendingRewards[msg.sender];\n        require(amount > 0, \"No funds to withdraw\");\n\n        // Reset the pending reward before transferring to prevent reentrancy\n        pendingRewards[msg.sender] = 0;\n\n        // Use call instead of transfer for better gas handling\n        (bool success, ) = msg.sender.call.value(amount)(\"\");\n        require(success, \"Transfer failed\");\n    }\n}\n"
}