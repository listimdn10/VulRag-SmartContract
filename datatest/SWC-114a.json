{
    "id": "SWC-114",
    "description": [
        "The Ethereum network processes transactions in blocks, with new blocks getting confirmed approximately every 17 seconds. Miners review the transactions they have received and select which ones to include in a block, based on who has paid a high enough gas price to be included. Additionally, when transactions are sent to the Ethereum network, they are forwarded to each node for processing. Thus, a person who is running an Ethereum node can tell which transactions are going to occur before they are finalized. A race condition vulnerability occurs when code depends on the order of the transactions submitted to it.",
        "The simplest example of a race condition is when a smart contract gives a reward for submitting information. Suppose a contract will give out 1 token to the first person who solves a math problem. Alice solves the problem and submits the answer to the network with a standard gas price. Eve runs an Ethereum node and can see the answer to the math problem in the transaction that Alice submitted to the network. So, Eve submits the answer to the network with a much higher gas price, and thus it gets processed and committed before Alice's transaction. Eve receives one token, and Alice gets nothing, even though it was Alice who worked to solve the problem. A common way this occurs in practice is when a contract rewards people for calling out bad behavior in a protocol by giving a bad actor's deposit to the person who proved they were misbehaving.",
        "The race condition that happens most frequently on the network today is the race condition in the ERC20 token standard. The ERC20 token standard includes a function called 'approve', which allows an address to approve another address to spend tokens on their behalf. Assume that Alice has approved Eve to spend n of her tokens, then Alice decides to change Eve's approval to m tokens. Alice submits a function call to approve with the value n for Eve. Eve runs an Ethereum node, so she knows that Alice is going to change her approval to m. Eve then submits a transferFrom request, sending n of Alice's tokens to herself, but gives it a much higher gas price than Alice's transaction. The transferFrom executes first so gives Eve n tokens and sets Eve's approval to zero. Then Alice's transaction executes and sets Eve's approval to m. Eve then sends those m tokens to herself as well. Thus, Eve gets n + m tokens, even though she should have gotten at most max(n,m)."
    ],
    "ERC20.sol": "pragma solidity ^0.4.24;\n\n/** Taken from the OpenZeppelin github\n * @title SafeMath\n * @dev Math operations with safety checks that revert on error\n */\nlibrary SafeMath {\n\n /**\n  * @dev Multiplies two numbers, reverts on overflow.\n  */\n function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n \n \n \n if (a == 0) {\n return 0;\n }\n\n uint256 c = a * b;\n require(c / a == b);\n\n return c;\n }\n\n /**\n  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\n  */\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n require(b > 0); \n uint256 c = a / b;\n \n\n return c;\n }\n\n /**\n  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n  */\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n require(b <= a);\n uint256 c = a - b;\n\n return c;\n }\n\n /**\n  * @dev Adds two numbers, reverts on overflow.\n  */\n function add(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a + b;\n require(c >= a);\n\n return c;\n }\n\n /**\n  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\n  * reverts when dividing by zero.\n  */\n function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n require(b != 0);\n return a % b;\n }\n}\n\n\ncontract ERC20 {\n\n event Transfer( address indexed from, address indexed to, uint256 value );\n event Approval( address indexed owner, address indexed spender, uint256 value);\n using SafeMath for *;\n\n mapping (address => uint256) private _balances;\n\n mapping (address => mapping (address => uint256)) private _allowed;\n\n uint256 private _totalSupply;\n\n constructor(uint totalSupply){\n _balances[msg.sender] = totalSupply;\n }\n\n function balanceOf(address owner) public view returns (uint256) {\n return _balances[owner];\n }\n\n\n function allowance(address owner, address spender) public view returns (uint256)\n {\n return _allowed[owner][spender];\n }\n\n function transfer(address to, uint256 value) public returns (bool) {\n require(value <= _balances[msg.sender]);\n require(to != address(0));\n\n _balances[msg.sender] = _balances[msg.sender].sub(value);\n _balances[to] = _balances[to].add(value);\n emit Transfer(msg.sender, to, value);\n return true;\n }\n\n function approve(address spender, uint256 value) public returns (bool) {\n require(spender != address(0));\n\n _allowed[msg.sender][spender] = value;\n emit Approval(msg.sender, spender, value);\n return true;\n }\n\n function transferFrom(address from, address to, uint256 value) public returns (bool) {\n require(value <= _balances[from]);\n require(value <= _allowed[from][msg.sender]);\n require(to != address(0));\n\n _balances[from] = _balances[from].sub(value);\n _balances[to] = _balances[to].add(value);\n _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);\n emit Transfer(from, to, value);\n return true;\n }\n}\n",
<<<<<<<< HEAD:datatest/SWC-114a.json
    "ERC20_fixed.sol":"pragma solidity ^0.4.24;\n\nlibrary SafeMath {\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 c = a * b;\n        require(c / a == b);\n        return c;\n    }\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0);\n        uint256 c = a / b;\n        return c;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a);\n        return a - b;\n    }\n\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a);\n        return c;\n    }\n\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0);\n        return a % b;\n    }\n}\n\ncontract ERC20 {\n    using SafeMath for uint256;\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    mapping(address => uint256) private _balances;\n    mapping(address => mapping(address => uint256)) private _allowed;\n\n    uint256 private _totalSupply;\n\n    constructor(uint256 totalSupply) public {\n        _balances[msg.sender] = totalSupply;\n        _totalSupply = totalSupply;\n    }\n\n    function balanceOf(address owner) public view returns (uint256) {\n        return _balances[owner];\n    }\n\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _allowed[owner][spender];\n    }\n\n    function transfer(address to, uint256 value) public returns (bool) {\n        require(value <= _balances[msg.sender]);\n        require(to != address(0));\n\n        _balances[msg.sender] = _balances[msg.sender].sub(value);\n        _balances[to] = _balances[to].add(value);\n        emit Transfer(msg.sender, to, value);\n        return true;\n    }\n\n    function approve(address spender, uint256 value) public returns (bool) {\n        require(spender != address(0));\n\n        // Mitigate race condition by requiring allowance to be set to 0 before updating\n        require(_allowed[msg.sender][spender] == 0, \"Allowance must be reset to 0 before updating\");\n        _allowed[msg.sender][spender] = value;\n        emit Approval(msg.sender, spender, value);\n        return true;\n    }\n\n    function transferFrom(address from, address to, uint256 value) public returns (bool) {\n        require(value <= _balances[from]);\n        require(value <= _allowed[from][msg.sender]);\n        require(to != address(0));\n\n        _balances[from] = _balances[from].sub(value);\n        _balances[to] = _balances[to].add(value);\n        _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);\n        emit Transfer(from, to, value);\n        return true;\n    }\n}\n"
========
    "ERC20_fixed.sol":"pragma solidity ^0.4.24;\n\nlibrary SafeMath {\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 c = a * b;\n        require(c / a == b);\n        return c;\n    }\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0);\n        uint256 c = a / b;\n        return c;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a);\n        return a - b;\n    }\n\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a);\n        return c;\n    }\n\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0);\n        return a % b;\n    }\n}\n\ncontract ERC20 {\n    using SafeMath for uint256;\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    mapping(address => uint256) private _balances;\n    mapping(address => mapping(address => uint256)) private _allowed;\n\n    uint256 private _totalSupply;\n\n    constructor(uint256 totalSupply) public {\n        _balances[msg.sender] = totalSupply;\n        _totalSupply = totalSupply;\n    }\n\n    function balanceOf(address owner) public view returns (uint256) {\n        return _balances[owner];\n    }\n\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _allowed[owner][spender];\n    }\n\n    function transfer(address to, uint256 value) public returns (bool) {\n        require(value <= _balances[msg.sender]);\n        require(to != address(0));\n\n        _balances[msg.sender] = _balances[msg.sender].sub(value);\n        _balances[to] = _balances[to].add(value);\n        emit Transfer(msg.sender, to, value);\n        return true;\n    }\n\n    function approve(address spender, uint256 value) public returns (bool) {\n        require(spender != address(0));\n\n        // Mitigate race condition by requiring allowance to be set to 0 before updating\n        require(_allowed[msg.sender][spender] == 0, \"Allowance must be reset to 0 before updating\");\n        _allowed[msg.sender][spender] = value;\n        emit Approval(msg.sender, spender, value);\n        return true;\n    }\n\n    function transferFrom(address from, address to, uint256 value) public returns (bool) {\n        require(value <= _balances[from]);\n        require(value <= _allowed[from][msg.sender]);\n        require(to != address(0));\n\n        _balances[from] = _balances[from].sub(value);\n        _balances[to] = _balances[to].add(value);\n        _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);\n        emit Transfer(from, to, value);\n        return true;\n    }\n}\n",
    "eth_tx_order_dependence_minimal.sol": "/*\n * @source: https://github.com/ConsenSys/evm-analyzer-benchmark-suite\n * @author: Suhabe Bugrara\n */\n\npragma solidity ^0.4.16;\n\ncontract EthTxOrderDependenceMinimal {\n address public owner;\n bool public claimed;\n uint public reward;\n\n function EthTxOrderDependenceMinimal() public {\n owner = msg.sender;\n }\n\n function setReward() public payable {\n require (!claimed);\n\n require(msg.sender == owner);\n owner.transfer(reward);\n reward = msg.value;\n }\n\n function claimReward(uint256 submission) {\n require (!claimed);\n require(submission < 10);\n\n msg.sender.transfer(reward);\n claimed = true;\n }\n}\n",
    "eth_tx_order_dependence_minimal_fixed.sol": "pragma solidity ^0.4.24;\n\ncontract EthTxOrderDependenceMinimal {\n    address public owner;\n    bool public claimed;\n    uint public reward;\n\n    mapping(address => uint) public pendingRewards;\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Caller is not the owner\");\n        _;\n    }\n\n    // Đổi tên hàm khởi tạo thành tên hợp đồng (dành cho Solidity ^0.4.x)\n    function EthTxOrderDependenceMinimal() public {\n        owner = msg.sender;\n    }\n\n    function setReward() public payable onlyOwner {\n        require(!claimed, \"Reward already claimed\");\n\n        // Refund the previous reward to the owner before updating\n        if (reward > 0) {\n            pendingRewards[owner] += reward;\n        }\n\n        reward = msg.value;\n    }\n\n    function claimReward(uint256 submission) public {\n        require(!claimed, \"Reward already claimed\");\n        require(submission < 10, \"Invalid submission\");\n\n        claimed = true;\n        pendingRewards[msg.sender] += reward;\n    }\n\n    function withdraw() public {\n        uint amount = pendingRewards[msg.sender];\n        require(amount > 0, \"No funds to withdraw\");\n\n        // Reset the pending reward before transferring to prevent reentrancy\n        pendingRewards[msg.sender] = 0;\n\n        // Use call instead of transfer for better gas handling\n        (bool success, ) = msg.sender.call.value(amount)(\"\");\n        require(success, \"Transfer failed\");\n    }\n}\n"
>>>>>>>> cce8e08e2f99a47339313f347f39a178f045d674:datatest/SWC-114.json
}